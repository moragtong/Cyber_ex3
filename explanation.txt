The reflected xss attack relies on the victim clicking a malicious link. The webpage shows a message according to a parameter given in the url
The parameter is accessed by the web server, and the web page is generated by the php file.
This allows the use of the <script> tags in the url payload to run a script on the victim's browser once they click on the url.
The stored XSS attack works by storing a malicious entry in the website, causing our code to run on the victim's next access.
The webpage inserts the comment to a database, and another webpage shows the database entries.
This allows us to write c code that sends an http request to the webpage, including our malicious comment that uses the <script> tags in the payload in the same manner as the reflected attack.
The DOM XSS attack also relies on the victim clicking a malicious link. However, in this case, the parameter we inject our malicious code with is actually JS client side logic, and uses parts of the URL to create dynamic page elements.
In this case, modern browsers provide protection against using <script> tags, and therefore the way to use the payload to inject our code is (after a # so our malicious code would only run on the client) to insert a premade error, and an error handler that calls the rest of the payload.
So far, we described how each attack causes our script to run. The rest is similar in all three attacks. The script forces a fetch GET request from the victim to the web server on the required site (according to each attack), using the cookie credentials of the victim to steal the web page. Afterwards, it sends the stolen page to the attacker server using a fetch POST request.

The server is almost identical for all three attacks. It creates a tcp server socket, binds it to the attacker server and listens for the victim to fall in our trap.
We accept the victim's connection and receive the raw web page requested by the malicious script, and write it to a text file (according to each attack).
We receive the raw web page by allocating a receiving buffer, chunk by chunk, until we get the entire http header.
We then parse the Content-Length in order to know how much is left to allocate. Now, the server can write the entire stolen web page into the text file.
